#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <assert.h>

int misses;
int accesses;

//must update these after every scan
//at some point will do misses/accesses to get miss rate, 

int main(int argc, char **argv){
    extern misses,accesses;
    //convert input parameters from string into int values
    int C = atoi(argv[1]);
    int K = atoi(argv[2]);
    int L = atoi(argv[3]);

    int i,j;
    
    int columns = K;
    //it's definitely a 1000, that TA was bullshit
    int rows = (C*(1000)/(K*L)); 

    //printf("%d\n", columns); 
    //printf("%d\n", rows); 

    int numberOfIndexBits = setIndexLength(rows);
    int numberOfOffsetBits = offsetLength(L);
    int numberOfTagBits = (32 - (numberOfIndexBits +numberOfOffsetBits));

    //initialize tagArray
    unsigned int **tagArray;
    tagArray = (int **) malloc(rows*sizeof(int *));
    for (i=0; i<rows; i++) tagArray[i]=(int *)malloc(columns*sizeof(int));

    //initialize lruArray
    unsigned int **lruArray;
    lruArray = (int **) malloc(rows*sizeof(int *));
    for (i=0; i<rows; i++) lruArray[i]=(int *)malloc(columns*sizeof(int));
    for (i=0; i<rows; i++){
        for (j=0; j<columns; j++){
            tagArray[i][j] = 0; //insert 0's into every cell in tagArray
            lruArray[i][j] = -1; //insert 1's into every cell in lruArray
        }
    }  
    //traceFile is located in argv[4]
    char const* const fileName = argv[4]; 
    //r = read only --> reads the traceFile
    FILE* file = fopen(fileName, "r");
    //initialize a character array with 9 cells (each cell = 1 byte) and store each character of address into each cell + 1 extra null since string 
    char line[9]; 


    //"line" contains the entire address, this loop gets each trace one by one 
    while (fgets(line, 10, file)) { 
        //converts current trace from a string to an int    
        int hexAddress = (int)strtol(line, NULL, 16); 
        //testing purposes to check if loop reads every trace in the file     
        //printf("%x\n", hexAddress); 
        int set = whichSet(numberOfTagBits,numbeOfOffsetBits,hexAddress)
        int tag = tagBits(numberOfOffsetBits,numberOfIndexBits,hexAddress)
        int way = hitway(int set, int tag,int **tagArray)
        if (way>-1){
            accesses++;
            misses++;
            updateOnMiss(set,tag,tagArray,lruArray)
        }else{
            accesses++;
            updateOnHit(set,tag,lruArray)
        }
    //THIS IS WHERE WE PRINT THE MISS RATE. MISS RATE = MISSESS/accesses   
    }
    //close file
    fclose(file); 
    return 0;

 //end of main
}

/*---------------------------------------FUNCTIONS BELOW-----------------------------------------------------*/


int logbase2(int number){
    int answer = 0;
    if((number%2) != 1){
      number = (number/2);
      answer++;
    }
    return answer;
}

//Outputs the number of bits in the set index field of the address.
int setIndexLength(int rows){
    int numberOfBits = logbase2(rows);
    return numberOfBits;
}

// Outputs the number of bits in the line offset field of the address.
int offsetLength(int L){
    int numberOfBits = logbase2(L/32);
    return numberOfBits;

 //Outputs the cache set in which the address falls.
 int whichSet(int numberOfTagBits, int numbeOfOffsetBits,int hexAddress){
    hexAddress = hexAddress<<numberOfTagBits;
    hexAddress = hexAddress>>(numberOfTagBits+numberOfOffsetBits);
    int set = hexAddress;
    return set;
    }

//Outputs the tag bits associated with the address.
int tagBits(int numberOfOffsetBits, int numberOfIndexBits, int hexAddress){ 
    hexAddress = hexAddress>>(numberOfOffsetBits + numberOfIndexBits);
    int tag = hexAddress;
    return tag;
    }
    
/*If there is a hit, this outputs the cache way in which the accessed line can be found; it returns //âˆ’1 if there is a cache miss.
set and tag have yet to be initiliazed and check that tagArray is initialized correctly */
hitWay(int set, int tag, int **tagArray){
    for (j=0; j<columns; j++){
      if tagArray[set][j] == tag{
        return j;
      }
    }
    return(-1);
}


//Updates the lruArray upon a hit. This function is only called on a cache hit.
updateOnHit(int set, int tag, int **lruArray){

}
//Updates the tagArray and lruArray upon a miss. This function is only called on a cache miss
updateOnMiss(int set, int tag, int **tagArray, int **lruArray){

}
